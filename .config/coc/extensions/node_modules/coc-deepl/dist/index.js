var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// src/index.ts
__markAsModule(exports);
__export(exports, {
  activate: () => activate
});
var import_coc4 = __toModule(require("coc.nvim"));

// src/deepl/Deepl.ts
var import_coc3 = __toModule(require("coc.nvim"));

// src/deepl/constants.ts
var DEEPL_PRO_PLAN_BASE_URL = "https://api.deepl.com";
var DEEPL_FREE_PLAN_BASE_URL = "https://api-free.deepl.com";
var DEEPL_TRANSLATE_ENDPOINT = "/v2/translate";
var MODES = {
  normal: "n",
  visual: "v"
};

// src/deepl/Deepl.ts
var import_url = __toModule(require("url"));

// src/deepl/utils/coc/getCurrentWord.ts
var import_coc = __toModule(require("coc.nvim"));
var getCurrentWord = async (mode) => {
  const doc = await import_coc.workspace.document;
  const pos = await import_coc.window.getCursorPosition();
  const range = mode === MODES.normal ? doc.getWordRangeAtPosition(pos) : await import_coc.workspace.getSelectedRange("v", doc);
  const text = range ? doc.textDocument.getText(range) : (await import_coc.workspace.nvim.eval('expand("<cword>")')).toString();
  return text.trim();
};

// src/deepl/getConfigurationValue.ts
var import_coc2 = __toModule(require("coc.nvim"));
var DEEPL_CONFIGURE_KEYS = {
  enabled: true,
  plan: "free",
  targetLanguage: "EN"
};
var getConfigurationValue = (key, defaultValue) => {
  const config = import_coc2.workspace.getConfiguration("deepl");
  return config.get(key, defaultValue);
};
var getDeeplIsEnabled = () => getConfigurationValue("enabled", DEEPL_CONFIGURE_KEYS.enabled);
var getDeeplPlan = () => getConfigurationValue("plan", DEEPL_CONFIGURE_KEYS.plan);
var getDeeplTargetLanguage = () => getConfigurationValue("targetLanguage", DEEPL_CONFIGURE_KEYS.targetLanguage);

// src/deepl/Deepl.ts
var Deepl = class {
  constructor(nvim, apiKey) {
    this.floatFactory = new import_coc3.FloatFactory(nvim);
    this.apiKey = apiKey;
    this.targetLanguage = getDeeplTargetLanguage();
    this.plan = getDeeplPlan();
  }
  async translate(mode) {
    const target = await getCurrentWord(mode);
    if (!target) {
      return;
    }
    const documentations = [];
    try {
      const res = await this.fetchTranslate(target);
      const translateResult = res.translations[0].text;
      if (!translateResult) {
        throw new Error("Translation failed.");
      }
      this.pushToMarkdownDocumentation(documentations, target);
      this.pushToMarkdownDocumentation(documentations, translateResult);
      await this.popup(documentations);
    } catch (err) {
      const message = err.message;
      import_coc3.window.showErrorMessage(message);
    }
  }
  pushToMarkdownDocumentation(documentations, message, prefix) {
    const filetype = "markdown";
    const content = prefix ? `
    ${prefix}
    ${message}
    ` : message;
    documentations.push({
      content,
      filetype
    });
  }
  async fetchTranslate(text) {
    if (!this.apiKey) {
      throw new Error("The API key for coc-deepl is not settings. Please see installation: https://github.com/kqito/coc-deepl#installation");
    }
    const url = new import_url.URL((this.plan === "free" ? DEEPL_FREE_PLAN_BASE_URL : DEEPL_PRO_PLAN_BASE_URL) + DEEPL_TRANSLATE_ENDPOINT);
    url.searchParams.set("auth_key", this.apiKey);
    url.searchParams.set("text", text);
    url.searchParams.set("target_lang", this.targetLanguage);
    try {
      const res = (0, import_coc3.fetch)(url.toString());
      const body = typeof res === "string" ? JSON.parse(res) : res;
      return body;
    } catch {
      throw new Error("Fetch failed.");
    }
  }
  async popup(documentations) {
    await this.floatFactory.show(documentations);
  }
};

// src/index.ts
async function activate(context) {
  const {subscriptions} = context;
  const {nvim} = import_coc4.workspace;
  const isEnabled = getDeeplIsEnabled();
  if (!isEnabled) {
    return;
  }
  const deepl = new Deepl(nvim, process.env.COC_DEEPL_API_KEY);
  subscriptions.push(import_coc4.workspace.registerKeymap(["n"], "deepl", async () => {
    await deepl.translate(MODES.normal);
  }, {sync: false}));
  subscriptions.push(import_coc4.workspace.registerKeymap(["v"], "deepl-selected", async () => {
    await deepl.translate(MODES.visual);
  }, {sync: false}));
}
